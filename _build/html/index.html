<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Optimal Algorithm for Intersections of a Set of Segments &mdash; OptimalSegmentIntersection 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OptimalSegmentIntersection 0.1 documentation" href="#" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="optimal-algorithm-for-intersections-of-a-set-of-segments">
<h1>Optimal Algorithm for Intersections of a Set of Segments<a class="headerlink" href="#optimal-algorithm-for-intersections-of-a-set-of-segments" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-statement">
<span id="id1"></span><h2>Problem Statement<a class="headerlink" href="#problem-statement" title="Permalink to this headline">¶</a></h2>
<p><strong>Given a set of line segments in 2D what is the most efficient way to find all
of the intersections between those segments?</strong></p>
<p>This problem is useful in a number of areas of computer graphics and as a
building block to more useful problems in computational geometry such as whether
a polygon or poly line can be considered &#8220;simple&#8221;.</p>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The object of this site is to present in an easy to understand way a few algorithms
used for 2D line intersection problems. This site will explore in particular a
few algorithms of interest:</p>
<ol class="arabic simple">
<li>The naive algorithm <span class="math">\(O(n^2)\)</span></li>
<li>The standard algorithm <span class="math">\(O((n+k)log(n))\)</span></li>
<li>Balaban’s optimal algorithm utilizing <span class="math">\(O(nlog(n) + k)\)</span> time and <span class="math">\(O(n)\)</span> space.</li>
</ol>
<p>Links to the original papers can be found in the References section of this site.
They contain more complete explanations of the overviews found here.</p>
</div>
<div class="section" id="the-bentley-ottman-algorithm">
<h2>The Bentley-Ottman Algorithm<a class="headerlink" href="#the-bentley-ottman-algorithm" title="Permalink to this headline">¶</a></h2>
<p>First, we present an overview of the standard algorithm, the Bentley-Ottmann also
known as the sweep-line algorithm. This is the standard algorithm because it is
very easy to implement and often performs well enough, in the case of a close to
linear k, it performs algorithmically as well as the optimal.</p>
<p>The overall strategy behind the Bentley-Ottmann algorithm is to sweep a vertical
line across the plane, maintaining the current vertical order of all lines
intersecting our sweep line. This allows us to process “events” as they come up
in the sweep line, inserting, swapping, or deleting elements depending on the
type of event encountered.</p>
<p>The Bentley-Ottmann algorithm can be described in the following steps:</p>
<ol class="arabic">
<li><p class="first">Initialize an event queue Q containing all x end points of lines in the set S</p>
</li>
<li><p class="first">Initialize an empty BST T that contains in vertical sorted order all line segments that intersect the sweep line.</p>
</li>
<li><p class="first">While Q is not empty, process the even E of minimum x value</p>
<blockquote>
<div><ol class="arabic simple">
<li>If E is a start point, insert the associated line into T, check segments
immediately above and below our line, if they cross our line then add that event to Q.</li>
<li>If E is an end point, remove the associated line from T, check segments
immediately above and below our line, if they cross each other then add that event to Q.</li>
<li>If E is an intersection, then check for intersections in its neighbors in
the tree T, adding relevant intersections to Q.</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="section" id="resource-analysis">
<h3>Resource Analysis<a class="headerlink" href="#resource-analysis" title="Permalink to this headline">¶</a></h3>
<p>Event Q size O(n+k), T size O(n), insert, delete, swap O(logn) per event, adding
intersection events O(logn) per event. Total time O((n+k)logn).</p>
<p>For a more complete analysis of the standard algorithms please visit Dan Sunday&#8217;s
site on <a class="reference external" href="http://geomalgorithms.com/a09-_intersect-3.html">Intersections of a set of segments</a>.</p>
</div>
</div>
<div class="section" id="the-balaban-algorithm">
<h2>The Balaban Algorithm<a class="headerlink" href="#the-balaban-algorithm" title="Permalink to this headline">¶</a></h2>
<p>This algorithm still uses a form of the sweep line used in the Balaban algorithm.
However, instead of slicing the horizontal event space into unit length pieces
in a linear fashon, we instead slice the event space into strips in a binary tree
of strips.</p>
<p>However, the most important concept to understand this algorithm is the usefulness of a
staircase (defined below). With the concept of a staircase, the Balaban line
intersection algorithm boils down into the following.</p>
<dl class="docutils">
<dt>For a strip between two vertical lines</dt>
<dd><ul class="first last simple">
<li>find a staircase Q and leftovers S</li>
<li>find intersections between Q and S</li>
<li>recurse on two smaller strips to find intersections between segments in S</li>
</ul>
</dd>
<dt>Intuitively this works if we realize two things.</dt>
<dd><ol class="first last arabic simple">
<li>It is very easy to find the intersections between a staircase and a set of
lines.</li>
<li>By seperating out staircases we are greatly reducing the amount of work
necessary in lower levels of the recursion.</li>
</ol>
</dd>
</dl>
<div class="section" id="preliminaries">
<h3>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">¶</a></h3>
<p>First a couple of definitions and notational elements:</p>
<dl class="docutils" id="strip">
<dt>strip <span class="math">\(\langle b,e\rangle\)</span></dt>
<dd>A strip represents a vertical strip from a beginning vertical line at <span class="math">\(x=b\)</span>
to an ending vertical line at <span class="math">\(x=e\)</span></dd>
</dl>
<dl class="docutils" id="span">
<dt>span</dt>
<dd>A segment <em>s</em> is said to span a <a class="reference internal" href="#strip">strip</a> <span class="math">\(\langle b,e\rangle\)</span> if <em>s</em> intersects both
lines <span class="math">\(x=b\)</span> and <span class="math">\(x=e\)</span></dd>
<dt>staircase <span class="math">\(\langle b,e\rangle\)</span></dt>
<dd><p class="first">A staircase is a sorted set of non-intersecting segments that <a class="reference internal" href="#span">span</a> the <a class="reference internal" href="#strip">strip</a> <span class="math">\(\langle b,e\rangle\)</span>.
This is useful as within the strip, for any line segment has a point in a particular stair
we can find the set of stairs that it intersects with as a range counting problem
which is accomplished <span class="math">\(O(log(n))\)</span> time.</p>
<p class="last"><strong>IMAGE HERE</strong></p>
</dd>
</dl>
<dl class="docutils" id="complete-staircase">
<dt>complete staircase</dt>
<dd>A staircase is complete relative to some set <em>S</em> if each segment of <em>S</em> either
does not span the <a class="reference internal" href="#strip">strip</a> <span class="math">\(\langle b, e\rangle\)</span> or intersects one of the
stairs of the staircase.</dd>
</dl>
<p>The function findStaircaseIntersections runs in <span class="math">\(O(|L| + |Int_{\langle b,e \rangle}(L)|)\)</span> time,
as for each line in L we do a contant number (2) intersection checks + the number
of successful checks.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="n">L_p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Q</span>   <span class="o">=</span> <span class="p">[]</span>                    <span class="c">#Ordered from lowest to highest</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">intersection</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">spans</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">L_p</span><span class="p">,</span> <span class="n">Q</span>
</pre></div>
</td></tr></table></div>
<p>This function splits a set ordered by intersecton with line b (or e for that matter)
into a <a class="reference internal" href="#complete-staircase">complete_staircase</a> Q and a remaining set of lines L_p (L prime). By inspection
of the function it is easy to conclude that split runs in <span class="math">\(O(|L|)\)</span> time and space.</p>
<div class="figure align-center" id="id7">
<a class="reference internal image-reference" href="_images/stairs.png"><img alt="_images/stairs.png" src="_images/stairs.png" style="width: 1024px;" /></a>
<p class="caption"><span class="caption-text">Figure 1: There are three possible complete staircases colorcoded in the figure above.
There are always many possible staircases, however these are the only 3 complete
staircases for this particular set of segments in this strip. All other possible
sets of segments either intersect, or can add another non-self intersecting segment
to the set, and are therefore either incomplete, or invalid staircases.</span></p>
</div>
<p><strong>IMAGE HERE Split process</strong></p>
<div class="highlight-python" id="searchinstrip"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">SearchInStrip</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="n">L_p</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L_p</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">Q</span>
        <span class="k">return</span> <span class="n">R</span>
    <span class="n">intersections</span><span class="p">,</span> <span class="n">R_p</span> <span class="o">=</span> <span class="n">findStaircaseIntersections</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">L_p</span><span class="p">)</span> 
    <span class="n">SearchInStrip</span><span class="p">(</span><span class="n">L_p</span><span class="p">,</span> <span class="n">R_p</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Merge</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">R_p</span><span class="p">)</span> 
</pre></div>
</td></tr></table></div>
<p>This function, given a set of line segments that <a class="reference internal" href="#span">span</a> the <a class="reference internal" href="#strip">strip</a> b, e, finds
all of the intersections between segments that occur in the strip, and as a
useful addition, finds the ordering of the segments of the set on the right
side of the strip, i.e. returns set R where R contains all segments of L ordered
by vertical intersection with the line <span class="math">\(x=e\)</span>. Below is an example of the
execution of the function SearchInStrip. This reordering of the lines is important
so that we are able to perform the same operation on the next strip to the right
of our current strip, as ordering the rightside of our strip is equivalent to
ordering the left side of the next strip.</p>
<div class="figure align-center" id="id8">
<a class="reference internal image-reference" href="_images/figure3.png"><img alt="_images/figure3.png" src="_images/figure3.png" style="width: 1024px;" /></a>
<p class="caption"><span class="caption-text">Figure 3: This figure is copied from Balaban&#8217;s paper <a class="footnote-reference" href="#id4" id="id2">[1]</a>. It shows the process
followed by the search in strip function on a set of 8 segments. Given a set of
segments sorted by their intersection with the left side of the strip <strong>L</strong>
we calculate a complete staircase <strong>Q</strong>.</span></p>
</div>
<p><strong>IMAGE HERE SEARCH INSTRIP</strong></p>
<p>The next question is how fast can we perform this procedure <a class="reference internal" href="#searchinstrip">SearchInStrip</a>?
It turns out that this procedure will, for a given set of lines <em>L</em> ordered by
intersection with the line <span class="math">\(x=b\)</span>, run in <span class="math">\(O(|L| + |Int_{\langle b,e \rangle}(L)|)\)</span>
time.</p>
<p>However, the problem with <a class="reference internal" href="#searchinstrip">SearchInStrip</a> is that it only works if all segments
span the strip. In fact if all segments spanned all strips, (a.k.a. all segments were lines)
to solve the original <a class="reference internal" href="#problem-statement">Problem_Statement</a> we could simply sort all of the line
segments by their slope (sort at <span class="math">\(x=-\infty\)</span>) and use a single <a class="reference internal" href="#searchinstrip">SearchInStrip</a>
call.</p>
<p>Therefore for our algorithm to work with segments in general, we use another
function which we will call TreeSearch. That deals with strips where adjacent
strips either add or remove one line segment. This works in general as we can
recursively split into strips that with 1/2 as many line beginnings and endings
using the fact that W.L.O.G we can relabel the <em>x</em> coordinates of the line
segments to be integers in the range 1...2N. We can then split down until each strip
is of size 1, where <span class="math">\(e-b = 1\)</span> in the new relabeled <em>x</em> coordinate system.</p>
<p>Therefore we present a first version of tree search.</p>
</div>
<div class="section" id="a-first-attempt">
<h3>A First Attempt<a class="headerlink" href="#a-first-attempt" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">TreeSearch</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">SearchInStrip</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">S_p</span> <span class="o">=</span> <span class="n">Split</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">Intersections</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">S_p</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">S_l</span> <span class="o">=</span> <span class="n">Crossing</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">S_r</span> <span class="o">=</span> <span class="n">Crossing</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

        <span class="n">TreeSearch</span><span class="p">(</span><span class="n">S_l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">TreeSearch</span><span class="p">(</span><span class="n">S_r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="tree-search">
<h4>Tree Search<a class="headerlink" href="#tree-search" title="Permalink to this headline">¶</a></h4>
<p>TreeSearch(S, b, e)</p>
<blockquote>
<div><ol class="arabic simple">
<li>If all segments cross the Strip, then perform a <a class="reference internal" href="#searchinstrip">SearchInStrip</a> operation, and return</li>
<li>Split S into a staircase Q, and a remainder <span class="math">\(S_p\)</span></li>
<li>Find intersections between Q and <span class="math">\(S_p\)</span></li>
<li>find the median endpoint <span class="math">\(c\)</span></li>
<li>Perform a TreeSearch on both sides, strips <span class="math">\(\langle b,c\rangle\)</span>, <span class="math">\(\langle c,e\rangle\)</span></li>
</ol>
</div></blockquote>
<p>While this algorithm will find all the intersections, it does not find them very
efficiently. Step 2, since S is an unordered set, we cannot complete efficiently.
Therefore for efficient staircase finding of S, we present a second attempt at
Tree Search, one with a new representation of S.</p>
<p>Note that with each successive level of tree search the number of lines shrinks
by at least the size of the staircase for each level. This is important later
in the overall time complexity of the algorithm.</p>
</div>
</div>
<div class="section" id="a-second-attempt">
<h3>A Second Attempt<a class="headerlink" href="#a-second-attempt" title="Permalink to this headline">¶</a></h3>
<p>To speed up the algorithm we view a set of lines in regards to a <a class="reference internal" href="#strip">strip</a> as a
union of three different sets. We say that a set <strong>S</strong> in reference to a strip
<span class="math">\(\langle b,e\rangle\)</span> is the union of three sets</p>
<blockquote>
<div><ul class="simple">
<li>L &#8211; All segments intersecting the line <span class="math">\(x=b\)</span> in sorted order</li>
<li>R &#8211; All segments intersecting the line <span class="math">\(x=e\)</span> in sorted order</li>
<li>I &#8211; The set of all segments that do not span the strip <span class="math">\(\langle b,e\rangle\)</span>
unordered.</li>
</ul>
<p><strong>IMAGE HERE EXAMPLE OF L R I</strong></p>
</div></blockquote>
<p>This representation is easy to create in <span class="math">\(O(|S|log|S|)\)</span> time. As it is an
<span class="math">\(O(|S|)\)</span> Operation to find those lines in each set and an <span class="math">\(O(|S|log|S|)\)</span>
peration to sort sets L, R.</p>
<p>Our new tree search uses this concept of a segment set instead, taking a sets
L, I, and S, and generating a set R, and all the intersections with the staircase
generated at that level.</p>
<div class="section" id="id3">
<h4>Tree Search<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre>def TreeSearch(L, I, b, e):
    if e - b == 1:
        R = SearchInStrip(L, b, e)
    else:
        L_p, Q =  split(L, b, e)
        intersections, R_p = findStaircaseIntersections(Q, L_p) 
        c = (b + e) / 2
        #Divide I into I_l, and I_r 
        R_l = TreeSearch(L, I_l, b, c)
        if p_c is a left endpoint:
            L_r = R_l.insert(p_c)
        else:
            L_r = R_l.delete(p_c)
        R_r = TreeSearch(L_r, I_r, c, e)
        intersections, R_p = findStaircaseIntersections(Q, L_p)     #TODO check
        for s in I:
            find stair of s                                         #using binary search 
        Find Int(Q, I)
        R = Merge(Q, R_r)
</pre></div>
</td></tr></table></div>
<p>TreeSearch(S, b, e)</p>
<blockquote>
<div><ol class="arabic simple">
<li>If all segments cross the Strip, then perform a <a class="reference internal" href="#searchinstrip">SearchInStrip</a> operation, and return</li>
<li>Split S into a staircase Q, and a remainder <span class="math">\(L_p\)</span>, note that the staircase must span <span class="math">\(\langle b,e\rangle\)</span>, but the remainder of L does not</li>
<li>Find intersections between Q and <span class="math">\(L_p\)</span></li>
<li>find the median endpoint <span class="math">\(c\)</span></li>
<li>Split the segments of I into <span class="math">\(I_{ls}\)</span> and <span class="math">\(I_{rs}\)</span></li>
<li>TreeSearch on the left side</li>
<li>Insert or delete the one segment that changed on the line C to get <span class="math">\(L_{rs}\)</span></li>
<li>Perform a TreeSearch on strip <span class="math">\(\langle c,e\rangle\)</span>, the right side</li>
<li>Find intersections between Q and <span class="math">\(R_{rs}\)</span></li>
<li>Find Location of left end point for each segment in I in the stairs</li>
<li>Find intersections between Q and I</li>
<li>Find the set R using knowledge about the child node&#8217;s R and the intersections of L</li>
</ol>
</div></blockquote>
<p><strong>IMAGE HERE</strong></p>
<p>This algorithm uses the concepts from the last version, only it takes into account
a faster representation of the set S, which makes the particulars more complicated.
Looking closely, we have effectively accomplished the same operation at each node
of the tree only with our new representation of the set S. However, this algorithm
runs more efficiently, in fact it runs in <span class="math">\(O(n log^2(n))\)</span> where n is the
number of segments in the original set S. The only slow step is step 10.
Which takes up to <span class="math">\(O(logn)\)</span> time at each node, the final algorithm improves
this step to an <span class="math">\(O(1)\)</span> operation, which improves the overall algorithm
time complexity to <span class="math">\(O(n logn)\)</span>.</p>
</div>
</div>
<div class="section" id="the-optimal-algorithm">
<h3>The Optimal Algorithm<a class="headerlink" href="#the-optimal-algorithm" title="Permalink to this headline">¶</a></h3>
<p>In the last algorithm to find the intersections between the set I and the current
staircase, we first have to locate the starting location of each of the segments
of I with a binary search, which then allows a <span class="math">\(O(1 + #Intersections)\)</span> per
segment search for stair intersections.</p>
<p>The idea here is to use stair location of the child nodes of the current node
to locate the segments in I. Specifically, by including every 4th stair in the
father node&#8217;s staircase in the current staircase. Intuitively, this increases
the current staircase size by a constant factor, which won&#8217;t change the time
complexities of any of the sub processes&#8217;.</p>
<p><strong>IMAGE HERE</strong></p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>I.J. Balaban, &#8220;An Optimal Algorithm  for Finding Segment Intersections&#8221;, Proc. 11-th Ann. ACM Sympos. Comp. Geom., 211-219 (1995)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Bernard Chazelle &amp; Herbert  Edelsbrunner, &#8220;An Optimal Algorithm for Intersecting Line Segments in the  Plane&#8221;, J. ACM 39, 1-54 (1992)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Brad Appleton, C++ code for an AVL balanced Tree, see: www.bradapp.com, oopweb.com/Algorithms/Documents/AvlTrees/VolumeFrames.html, www.bradapp.com/ftp/src/libs/C++/AvlTrees.html (1997)</td></tr>
</tbody>
</table>
<ul class="simple">
<li><a class="reference internal" href="search.html"><span>Search Page</span></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Optimal Algorithm for Intersections of a Set of Segments</a><ul>
<li><a class="reference internal" href="#problem-statement">Problem Statement</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#the-bentley-ottman-algorithm">The Bentley-Ottman Algorithm</a><ul>
<li><a class="reference internal" href="#resource-analysis">Resource Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-balaban-algorithm">The Balaban Algorithm</a><ul>
<li><a class="reference internal" href="#preliminaries">Preliminaries</a></li>
<li><a class="reference internal" href="#a-first-attempt">A First Attempt</a><ul>
<li><a class="reference internal" href="#tree-search">Tree Search</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-second-attempt">A Second Attempt</a><ul>
<li><a class="reference internal" href="#id3">Tree Search</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-optimal-algorithm">The Optimal Algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Alex Tong.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/index.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>